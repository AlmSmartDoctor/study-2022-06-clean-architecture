# 진행 자료

# 계층과 경계.

기본적인 컴포넌트만으로(GUI, 업무규칙, DB) 충분할까? => **아님!!**


## Wumpus Game
- 명령어 기반 텍스트 UI 게임


### 다양한 시장을 위한 UI분리
![](1.png)
- 이런 경우에 UI자체가 컴포넌트로 분리되고 **언어** 라는 특성이 경계를 분리하기 위한 변경의 축이 된다.
- 의존성 관리가 잘된다면, 해당 추가사항은 중요한 로직, 실제 게임의 룰은 영향을 받지 않는다.
- 최종적으로는 UI뿐만 아니라 데이터 저장소 역시 저장소 종류라는게 변경의 축이 되고 해당, 의존성에 대한 관리를 한다면, 게임의 룰에 영향이 없다.
  ![](2.png)


### 이런 분리가 충분할까?
![](3.png)
- UI의 변경의 축은 언어만 있을까?
    - 텍스트를 주고받는 방식이 될수도 있다
    - Text Delivery, Language, DataStore를 추상 컴포넌트로 만듬으로써, Language라는 특성을 TextDelivery로 부터 격리 시킨다.(231p.일차원 경계)
    - Boundary 인터페이스는 상위 컴포넌트에 위치하고 하위 컴포넌트에서 구현해준다. (그림 25.4참조)
    - 이런 API컴포넌트(다형적 인터페이스)는 여러 구현체들로 존재할수 있게 된다.
    - LSP법칙을 지킨다면(p.82), API 컴포넌트를 구현체 컴포넌트로 교체하더라고, 행위는 변하지 않을것이므로, 그로 인해 아키텍처자체를 다형적으로 만들수 있을것이다.
      ![](4.png)

### 데이터 흐름
- [User] -> TextDelivery -> Language -> GameRules -> DataStorage
- GameRules -> Language -> TextDelivery -> [User]

### 흐름 횡단(Crossing)
- 횡단이 저렇게 단순한 두가지만 존재할까?
    - Network를 추가해 멀티플레이를 지원하게 된다면,
    - "Network"라는 새로운 컴포넌트가 필요해진다.
    - 데이터 흐름은
        - 이전거 외에도
        - GameRule -> Network라는 새로운 흐름이 추가될것.
          ![](5.png)

### 흐름 분리
- 흐름은 최상단 컴포넌트에서 만나게 될까?
    - 최상단 컴포넌트 자체가 분리될지도 모른다!
        - 플레이어상태(게임상태)
        - 맵, 오브제, 게임 이벤트 처리
        - 만약, MMO 게임이라면? -> 이런 최상단 컴포넌트에 대한 처리를 나눠서 처리하게 한다면,(PlayerManagement - 서버/ MoveManagement - user PC)
        - 분리가 될수 밖에 없음.


> _**이런 경계 분리가 꼭 모두 예측해서 할 필요도 없고, 그래선 안된다.
> 필요하다고 인지되는 경우에 분리를 해야한다.**_

# 메인 컴포넌트
- 책에서 DIP설명하는 부분에서 최초로 언급되고, (p.95)
- 이때 우리는 DIP를 위배하는 클래스(컴포넌트)라고 인지를 하고 있을 겁니다.
- 이 개념을 기반으로 좀더 자세히 알아보는 챕터.

### 궁극적인 세부사항.
- 책에서는 궁극적인 세부사항(가장 낮은 수준 정책)으로 표현하는데, 그이유로는
    - Factory, Strategy패턴들이 실제로 일하는곳
    - 의존성 주입이 실제로 일어나는곳

### Wumpus Game
- 구체적인 문자열을 다른 영역에서 알지못하게 (private) 선언했다.
- HtwFactory는 문자열로 참조해서 메인이 해당 클래스에 의존성을 갖지 않게함.(즉, 메인에도 의존성은 존재함)
- 기본적인 설정(InputStream ,main loop, Command Exec.)는 메인에서 처리, 실제 로직은 `game`을 통해 처리.
- 지도생성

> _**메인 컴포넌트는 애플리케이션의 플러그인, 애플리케이션의 선택사항
> 초기조건설정, 외부자원수집, 제어권 토스 담당.**_


# 크고 작은 모든 서비스들

### 서비스 지향 아키텍처, 마이크로서비스 아키텍처
- 상호 결합이 분리되는 것처럼 보임.
- 개발, 배포 독립성을 지원하는것처럼 보임.

**이런 믿음은 일부만 맞는 말이다.**

### 서비스 아키텍처 ...?

- 서비스를 사용한다는게 본질적으로 아키텍처를 적용했다는건 아님.
    - 아키텍처는 `의존성 규칙`, `경계`에 의해 정의된다.
- 서비스는 그자체로 의미를 갖지만, 이책에서는 일단, 아키텍처로 중요한 서비스에 대해 알아보자.

## 서비스의 이점?
- 결국 위에서 봤던 아키텍처에 대한 장점으로 보이던 부분들이, 실제로는 무조건 맞는 말이 아니다!

### 결합분리의 오류
- 다른 프로세서, 다른 프로세스지만
- 네트워크 상의 [공유자원](https://ko.wikipedia.org/wiki/%EA%B3%B5%EC%9C%A0_%EC%9E%90%EC%9B%90) 으로 인해 결합될 가능성이 여전히 존재.
- 서비스들 사이 공유된 레코드가 존재한다면, 이 레코드에 대한 변경이 모두에게 연결되야한다. (수정에 닫혀있지 않음.)

### 개발 및 배포 독립성의 오류
- 대규모 엔터프라이즈 시스템은 모노리틱 시스템, 컴포넌트 기반 시스템으로도 구축가능
- 데이터나 행위에 대해 결합이되어 있다면, 개발,배포,운영이 조정해야된다(독립적이지 않음)

## 야옹이 문제
![](cat.jpg)
- 택시통합시스템의 확장판(p.84)
- 확장성을 위해 마이크로서비스 기반 구축
  ![](6.png)
- TaxiUI: 고객 담당하는 앱
- TaxiFinder: Supplier 현황에 따른 택시 후보 선별
- TaxiSelector: 고객기반에 택시 선별
- TaxiDispatcher: 실제 택시 배차

### 야옹이 배달에 대한 기능 추가 요청
- 요구사항
    - 고객의 집, 사무실로 야옹이 배달
    - 야옹이 승차 지점 설정
    - 택시 선택
        - 참여하지않는 업체도 존재
    - 야옹이 배달
        - 해당 차량은 고양이 알러지 고객으로 인해 3일단 해당 고객 배차 불가

- 이 요구사항을 맞추기 위해선,
    - 고객에 대한 새로운 UI
    - TaxiFinder에서 Supplier에 대한 조건 추가
    - TaxiSelector에서 승차지점 근처에 대한 조건 추가
    - TaxiDispatcher에서 알러지 승객에 대한 차단 추가
- 모든 서비스가 다 바뀌어야한다.
- 즉, 기능 개발을 위해 모든 서비스가 **수정**되어야한다! (OCP준수 하지 못함)


### 객체 도입!
- 컴포넌트 기반 아키텍처에선 이 문제를 다형적으로 확장할 수 있는 클래스 집합을 통해 해결(이 클래스집합은 SOLID, 특히 LSP를 만족)
- 인터페이스는 아니지만, 일차원 경계의 개념(양방향 격리)로 보인다.
    - 실제로 stratege 패턴을 언급하고, 이전 p.231에서도 strategy패턴을 언급함.
    - 템플릿 메서드에 대한 설명도 하면서 공통 로직 부분에 대한 구현은 실재하고, 이후 더 상세한 구현들을 **추가**하면서, 의존성 규칙을 준수하고, 경계도 더 나누며, SOLID규칙들도 지킨다.
      ![](7.png)

### 실제 서비스에서는?
- 물론 가능.
- 자바에 경우엔 서비스를 `하나 이상의 jar파일에 포함되는 추상클래스들의 집합`이라고 생각하라고 한다.
    - 배포에서 서비스 로드 경로에서 새로운 jar파일만 추가하면된다. UI를 제외하면 변경은 없다!
      ![](8.png)
- 다이어 그램을 보면 서비스(TaxiFinder ,TaxiSelector, TaxiDispatcher, Ride Supplier)는 내부 자신만의 컴포넌트 설계가 따로 있다.
    - 이 다이어그램만 보면, 수평적인(같은 수준의) 내부 컴포넌트들만 있는데, 이렇게 밖에 안되나?
- 단순히 파생클래스의 추가만으로 신규기능 추가가 가능하다.

### 횡단 관심사
- 다수에 핵심적인 컴포넌트에 들어가는 영향을 끼치는 관심사.
- 이런 횡단 관심사까지 분리하기 위해선, 다음 다이어그램처럼, 서비스내부에서도 의존성 규칙을 준수하는 컴포넌트 아키텍처로 설계해야한다.
- 실제로 아키텍처의 경계를 정의하는 부분은 서비스 내부의 컴포넌트 들이다.
  ![](9.png)


---

# 질의응답

```text
지인: 26장에서 예시로 주어지는 코드가 너무 길어서 이해하기가 조금 귀찮네요...ㅎㅎ
조금 간략하게 정리해서 한 번 설명해주실 수 있나요?

대답: 
StreamInput, println -> 메인컴포넌트상의 presentation처리부분
System.in, System.out -> 플러그인 컴포넌트 presentationlayer
HuntTheWumpusFacade -> Main 컴포넌트중에서도 가장 더러운 부분
game.make(Move/shoot)Command -> 실제 로직이 실행되는 부분
루프 -> 실행 환경
string, map -> 리소스 생성 및 구체적인 리소스는 다른 컴포넌트에서 알지 않도록 하는것
같습니다.
```

```kotlin
@SpringBootApplication
@EnableTransactionManagement
@EnableAsync
@EnableCaching
class AutoReceiptApplication

fun main(args: Array<String>) {
    runApplication<AutoReceiptApplication>(*args)
}
```
```text
하진: (26장) 스프링 부트의 main에는 아무것도 없습니다.
위의 코드는 자동접수의 예시입니다.
메인 class에 설정 어노테이션이 3개 정도 붙어있기는 하지만, 그것들도 귀찮아서 메인에 달아둔 것이지 다른 Configuration 클래스로 완전히 분리시킬 수 있으므로, 사실상 아무 것도 없습니다.
사용자와의 상호작용은 스프링 부트가 컨트롤러의 메소드와 상호작용하는 것으로 처리되구요.
그래서 안드로이드, 웹 프론트, C# 등 여러 환경(내지는 프레임워크)마다 entry driver(entry point)를 관리하는 방법이 궁금합니다.

발표자분께서 해당하는, 혹은 겪어보신 환경의 사례를 공유해주실 수 있으신가요?
그리고 스터디할 때 각 팀/파트별로 사례를 공유하는 시간을 가졌으면 좋겠습니다 :)

대답: 
Android > Dagger Hilt(https://dagger.dev/hilt/entry-points.html)를 사용, entrypoint 더 정확히는 AndroidEntry가 진입점이 되고, 여러 Hilt Component별로(모바일은 Singleton 사용) 정의된 의존성 주입을 해줍니다.
C# > ioc 클래스를 만들어서 여기서 주입
React > index.tsx
ios > 명시적으론 없음
```

```text
규훤:
컴포넌트 또는 모듈의 경계를 나누는 기준은 어디까지로 잡아야 할까요?

너무 작게 잡으면 255pg의 택시 프로그램처럼 사실상 하나가 될 수 있는 상태이고,
그렇다고 크게 잡기에는 서비스 전체를 하나로 잡아도 되는 상태이다 보니...

단순히 레이어를 기준으로 모듈이나 컴포넌트를 나누는 것도 이상한 것 같고...

진영씨! 날 보고 있다면 정 답을 알려줘...!

대답:
일단 이 책에서의 가정처럼 마이크로 서비스 및 적당한 수의 서비스라고 생각을 하고 답하겠습니다.
그렇게 생각하면 각각의 서비스가 하나씩의 모듈이라고 일단 p.255에선 생각해볼수 있을것같습니다. 마이크로 서비스라면, 이후 그림(p.257,258)에서 보면 각각의 서비스 내부에서도 컴포넌트가 분리가 되고 있죠. 그럼 그 컴포넌트 간에도 경계를 세울수 있을것같습니다. 
레이어를 기준으로 컴포넌트를 나누는것도 크게 이상한 부분은 아닌것 같습니다. 중요한건 레이어만으로 분리하려고 하지 않는다는 점입니다.(GUI, DATA, Business Rules), 후보 택시들, taxiSupplier를 일종의 DataSource/Repository라고 볼수 있을 것 같습니다. 또 TaxiUi를 GUI로 볼수 있겠죠. 나머지는 Business Rule이라고 볼 수 있는 것 같습니다.  책에서는 이걸 단순한 세 파트로 나누지 않습니다. 좀 경계선을 나눈거죠.

결론적으로 질문인 경계의 기준에 대해 말하면, 이상적으로는 모든걸 나눠두는게 (책에 나오는것 이상으로까지도) 그리고 이후를 위해 추상 컴포넌트(서비스)를 사용해서 구현하는게 맞을 것같습니다. 하지만 아키텍처의 목적을 생각해서 개발,배포,운영,유지보수 비용을 줄이는 방향으로 나아가야하지 아키텍처를 위한 아키텍처를 만들어 버린다면 그건 오히려 아키텍처의 목적을 위배하는게 되지 않을까 싶네요!
```

```text
진호: 프로젝트 초기에 야옹이 문제를 대비하기 위해
p.257의 다이어그램 구조를 사용해야 할까요?
제 생각엔 YAGNI 원칙에 의하면 일단 전체를 하나의 서비스로 만들고,
기능 추가점이 생길 때 원래도 약하게는 분리되어있던
Selector 등을 서비스로 빼는 것이 나아보여요.
"객체가 구출하다"라는 거창해보이는 부제때문에
어느 것이 더 좋은지 헷갈리네요.

대답: 
어느쪽이 더좋다.. 이런 내용은 답하기 정말 어려운 내용인것같습니다. 회사마다 혹은 프로젝트마다 추가적인 "정책"이 존재할 수 있다고 봅니다. 제가 말하는 이런 "정책"이란 건 구체적인 기능에 대한 내용이 아닙니다. 만약 프로젝트 자체가 확장성을 굉장히 고려하고 있다면, 처음부터 구조를 짜두는게 더 효과적일 수 있겠죠. 그렇지 않다면 반대고요.
그런 관점에서 야옹이 문제의 경우도, 만약 회사가 "운송" 에 초점을 맞춘 정책을 가지고 있다면, 해당 서비스를 미리 구현해두는게 더 효율적일수 있다고 생각합니다.
하지만, 아무런 조건없이, 단순한 택시서비스를 지원하고자고 한다면 굳이 필요한 부분은 아닐거라고 생각합니다.
```

```text
천규:
1) 250p에서 둘 이상의 메인 컴포넌트를 만들 수 있다는 것은 메인 컴포넌트 이외의 컴포넌트들을 공유하는
별도의 프로그램을 만들 수 있다는 의미인가요? 설마 시작점이 여러개가 될 리는 없을 것 같고...
 
2) 그림 27.3을 보니 정신이 아득해지는데, 서비스 사이에도 SOLID 원칙을 구현한다는 것이
어느정도 감은 잡히지만 실제로 어떻게 되는 것인지 잘 모르겠습니다.
예를 들어 그림에 나온 Taxi Selector, Taxi Finder, Taxi Dispatcher 등은 마치 인터페이스처럼 보이는데,
이러한 서비스들은 어떻게 구현하면 좋을까요?
 
대답: 
1) 메인 컴포넌트를 "애플리케이션의 플러그인"이라고 결론에서 얘기하고 있습니다. 이 말에는 이 컴포넌트가 
세부사항이라는 의미가 담기고, 저희는 세부사항들을 선택사항으로 간주하고있죠.
그런 면에서 메인 컴포넌트를 둘 이상 만들 수 있다는 점은 마치 GUI가 cli, web, app... 으로 나뉘는 것처럼(250p. 마지막 부분 아래에도 언급되듯이) 여러 역할에 대한, 설정값을 포함한, 플러그인들을 여러개 만들 수 있다는 것같습니다.
또한 메인 컴포넌트라는건 거의 웬만해선 "하나"가 맞는것 같습니다. 서비스까지 컴포넌트 단위가 나뉘더라도, 서비스 별이 아니라 최초 진입 서비스 쪽에서 해당 설정값을 해주는게 의미가 있지, 그걸 서비스마다 또 설정을(게다가 같은 걸로)해주는건 CCP, SRP에 위배되는 방향이라고 생각합니다.

2) 저도 일단 정확히 이해했다고 보긴 어렵습니다만..
256p에서 횡단 관심사에 대한  문제점을 지적하고 이후 컴포넌트 기반 서비스를 통해서 그 문제점을 해결하고자 합니다. 그래서 저는 횡단 관심사에 중점을 두고 서비스 구현의 방식을 생각해봤습니다. 
횡단 관심사는 대부분의(혹은 모든) 컴포넌트에 영향을 끼쳐서 생기는 문제점입니다.(모든 컴포넌트를 수정하게 만들면서 OCP를 준수하지 못하게 됨) 책에서 나온 컴포넌트 기반 서비스의 경우에는, 일부분의 컴포넌트(서비스)를 추상 클래스로 둬서 공통적인 로직을 유지하고, 케이스별로 결정되는 일부 세부사항들(Kitten, Rides)을 서비스 내부 컴포넌트로 구현시킵니다.(OCP 준수)
즉, 구현에 대한 부분은 서비스 -> 공통로직 담당/ 내부 컴포넌트(구현체) -> 세부사항 구현 이렇게 나눌수 있을것 같습니다.
```

```text
준우: 248p의 main 함수에서 makeGame 호출시 ```HuntTheWumpusFacade```와 ```new Main()``` 을 넘겨주는데 여기서 new Main으로 새로 생성된 인스턴스를 전달하는 이유가 무엇인지 궁금하네요.

대답:
왜 굳이 Singleton 같은 개념을 사용하지 않느냐는 질문으로 받아들였는데 맞는지 모르겠네요!
우선, Main Class는 메인컴포넌트에 대한 클래스라는 것을 분명히 해두고 가야할것같습니다. 그리고, Main 객체를 선언한것과 Main객체를 Singleton혹은 변수로 할당해서 변수로 담고있는게 결국 (현재 코드에서는)같은 개념이라고 보면 될것같습니다.  Main 객체가 사용되는 부분이 makeGame밖에 없기 때문이죠. 만약에 이후에 makeGame이외에도 Main 객체가 필요하다면, Singleton이나 객체 하나로 들고 있는 게 나을 수도 있겠죠..


```

```text
이영:클라이언트와 서비스가 강하게 결합되어 아키텍처적으로 아무런 의미가 없을때도 있다는데(259p)
 이해가 잘 안돼서 혹시 예시하나 들어주실 수 있을까요ㅠ

대답: 

결론:  클라이언트에 변경이 돼도, 서비스가 수정이 되는 경우가 생긴다면, 
분리되는 의미가 없다. (결국  둘다 수정돼야함)
```

```text
영재:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
가온: 253쪽에서 서비스가 네트워크 상의 공유 자원 때문에 결합될 가능성이 존재한다고 하였는데, 구체적으로 어떤 경로로 결합도가 높아진다는 것인지 궁금합니다. 259쪽에서 이 서비스가 클라이언트와 결합될 수 있다는 이야기를 하였는데, 이 부분도 어떤 의미인지 잘 이해가 되지 않아 질문드립니다!

대답: 
https://en.wikipedia.org/wiki/Shared_resource  공유자원이라는 개념이 찾아보니까 따로 있는 개념인 것 같습니다. 주로 여러 네트워크 호스트들에서 접근이 가능한 리소스라고 하는데 저희 회사에선 예를 들어 모두가 접근 가능한 ftp 로컬 서버같은게 있을것같네요. 이처럼 여러 곳에서 접근이 가능한 리소스를 공유하고 있다면, 한쪽에서 리소스에 대한 수정이 일어나면, 다른 공유하던 호스트들도 수정을 해야하는 경우, 즉 서로에 대한 의존성이 생겨버릴 수 있다는 것같습니다.
클라이언트/ 서비스 결합 문제는 이영님 질문과 같은것같아서 그부분에서 토의해보죠.. 저도 잘 모르겠는 부분이라..
```
