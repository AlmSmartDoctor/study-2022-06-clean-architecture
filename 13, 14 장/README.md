# 진행 자료

# 컴포넌트 응집도

- 어떤 클래스를 어느 컴포넌트에 포함시켜야할까?
- 이는 중요한 결정이므로 제대로 된 소프트웨어 엔지니어링 원칙의 도움을 받아야한다.
- 하지만 우리는 임시방편적으로 결정을 내려왔다.

<br/>

- 이 장에서는 컴포넌트 응집도와 관련된 세 가지 원칙을 논의한다.
1. REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
2. CCP: 공통 폐쇄 원칙 (Common Closure Principle)
3. CRP: 공통 재사용 원칙 (Common Reuse Principle)

## REP: 재사용/릴리스 등가 원칙

| 재사용 단위는 릴리스 단위와 같다.

- 지난 십 년은 모듈 관리 도구가 우후죽순으로 등장한 시기였다.
- 이 기간에 재사용 가능한 컴포넌트나 라이브러리가 엄청나게 많이 만들어졌기 때문에, 이 같은 도구들은 점점 중요해졌다.

<br/>

- 돌이켜보면 REP는 너무 당연해 보인다.
- 컴포넌트가 추적 관리되지 않거나, 릴리스 번호가 부여되지 않는다면 재사용하고 싶어도 할 수 없고, 하지도 않을 것이다.
- 즉 릴리스에 충분한 정보가 있어야 개발자가 새 릴리스를 통합할지, 한다면 언제할지 결정할 수 있다.

<br/>

- 이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.
- 즉 컴포넌트를 구성하는 모든 모듈을 서로 공유하는 중요한 테마나 목적이 있어야한다.

<br/>

- 이 사실은 물론 너무 당연하다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 
1. 버전 번호가 같아야 하며 
2. 동일한 릴리스로 추적 관리되고
3. 동일한 문서에 포함되어야 한다
- 는 사실은 컴포넌트 제작자 입장이나 사용자 입장에서도 이치에 맞는 얘기다

<br/>

- 하지만 이 원칙의 조언은 약하다.
- 구체적인 해결 방법을 제시해주지는 못하기 때문이다.
- 이 원칙의 약점은 다음에 다룰 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있다.

## CCP: 공통 폐쇄 원칙 

| 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

- 이 원칙은 SRP를 컴포넌트 관점에서 다시 쓴 것이다.
- SRP에서 단일 클래스는 변겨의 이유가 여러 개 있어서는 안 된다고 말하듯이, CCP에서도 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다고 말한다.

<br/>

- 대다수의 어플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다.
- 어플리케이션 코드가 반드시 변경되어야한다면, 변경 사항이 여러 컴포넌트에 분산되어 발생하는 것보다, 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
- 변경된 컴포넌트만 재배포하면 되기 때문이다.

<br/>

- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.
- 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.

<br/>

- 이 원칙은 OCP와도 밀접하게 관련되어 있다.
- OCP에서 말하는 폐쇄와 CCP에서 말하는 폐쇄와 뜻이 같다. 즉 변경에 닫혀있어야한다.
- 하지만 100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 한다.
- 따라서 변경이 생겼을 때, 그 변경으로 영향을 받는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.

<br/>

## CRP: 공통 재사용 원칙

| 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

- CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다.
- 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용 하는 경우가 많다.
- 간단한 사례로 컨테이너 클래스와 해당 클래스의 이터레이터 클래스를 들 수 있다.
- 이 클래스들은 강하게 결합되어 있기 때문에, 이 클래스들은 반드시 동일한 컴포넌트에 위치해야 한다.

<br/>

- CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.
- 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생긴다.
- 어쩌면 단 하나의 클래스만 사용하는 상황일 수도 있다. 하지만 그렇다고 해서 의존성은 조금도 약해지지 않는다.
- 이 같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다.
- 따라서 의존해야 하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

<br/>

- 바꿔 말하면, 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다.
- 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.
- 따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다.

## 컴포넌트 응집도에 대한 균형 다이어 그램

- 응집도에 관한 세 원칙이 서로 상충된다는 것은 눈치챘을 것이다.
- REP와 CCP는 포함 원칙이다.
- 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.
- CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.

![](https://velog.velcdn.com/images/eplue/post/38cf3965-ecb6-415c-9b52-21568de1f674/image.png)

- 오로지 REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.
- 반대로 CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.
- 뛰어난 아키텍트라면 이 규현 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 한다.
- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 이 때는 오직 재사용성만 희생하면 된다.
- 점차 프로젝트가 성숙해지면서, 프로젝트는 점차 왼쪽으로 이동해간다.

# 컴포넌트 결합

- 지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.
- 이 장에서 만찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다.
- 컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.

## ADP: 의존성 비순환 원칙 (Acyclic Dependencies Principle)

| 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

- 하루 종일 일해서 무언가를 작동하게 만들고, 다음날 출근해보면 돌아가지 않는 경험을 해본적이 있지 않은가?
- 왜냐하면 누군가 단신이 의존하고 있던 무언가를 수정했기 때문이다.
- 저자는 이런 현상을 '숙취 증후군'이라고 부른다.

<br/>

- 숙취 증후군은 소수의 개발자로 구성된 상대적으로 작은 프로젝트에서는 이 증후군이 그다지 큰 문제가 되지 않는다.
- 하지만 프로젝트와 개발팀의 규모가 커지면 숙취는 지독한 악몽이 될 수도 있다.
- 지난 수십년간 이 문제의 해결책으로 두 가지 방법이 발전되어 왔다.
- 첫 번째 해결책은 '주 단위 빌드'이며
- 두 번째 해결책은 '의존성 비순환 원칙'이다

### 주 단위 빌드 (Weekly Build)

- 주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다.
- 주 단위 빌드를 하는 방법은 다음과 같다.
1. 모든 개발자들은 4일 동안 서로 신경쓰지 않고 개발한다. 즉 어떻게 통합할지 걱정하지 않는다.
2. 그런 후 4일이 지나면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
- 이 접근법은 5일 중 4일동안 개발자를 고립된 세계에서 살 수 있게 보장해준다는 아주 멋진 장점을 가진다.
- 물론 단점은 금요일에 통합과 관련된 막대한 업보를 치러야 한다는 사실이다.

<br/>

- 안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루 만에 끝마치는게 불가능해진다.
- 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
- 이 같은 흐름은 마침내 위기를 초래한다.
- 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커진다.

### 순환 의존성 제거하기

- 이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
- 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
- 해당 개발자는 컴포넌트를 동작하게 만든 후 다른 개발자가 사용할 수 있도록 컴포넌트를 릴리스한다.
- 컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다.
- 적용하지 않기로 했다면 그냥 과거 버전의 릴리스를 계속 사용한다.
- 따라서 어떤 팀도 다른 팀에 의해 좌우되지 않는다.
- 각 팀은 새롭게 릴리스된 특정 컴포넌트에 맞춰 수정할 시기를 스스로 결정할 수 있다.
- 즉 통합은 작고 점진적으로 이루어진다.

<br/>

- 이 방식은 단순하며 합리적이어서 널리 사용되는 방식이다.
- 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.
- 의존성 구조에 순환이 있어서는 안 된다.

![](https://sungjk.github.io/images/2019/10/26/14_1.png)

- 위 다이어그램에서는 컴포넌트를 조립하여 어플리케이션을 만드는 다소 전형적인 구조를 볼 수 있다.
- 중요한 점은 컴포넌트 간의 의존성 구조다.
- 한 가지 더 주목할 점이 있다. 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아 갈 수 없다는 것이다.
- 즉 비순환 방향 그래프다.

<br/>

- 이제 Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리스를 만들면 무슨 일이 벌어질지를 생각해보자.
- 이 릴리스에 영향받는 팀은 의존성 화살표를 거꾸로 따라가면 쉽게 찾을 수 있다.
- 즉 View, Main 컴포넌트 둘 다 영향을 받는다.
- 이 두 컴포넌트를 작업 중인 개발자라면, Presenter의 새로운 릴리스와 자신의 작업물을 언제 통합할지를 반드시 결정해야 한다.
- 또한 Main은 새로 릴리스되더라도 시스템에서 이로 인해 영향받는 컴포넌트가 전혀 없다는 사실에 주목하자.
- 나머지 컴포넌트는 Main에 대해 알지 못하므로 Main이 변경되더라도 전혀 개의치 않는다.

<br/>

- Presenters 컴포넌트를 만드는 개발자가 이 컴포넌트를 테스트하고자 한다면, 단순히 현재 사용 중인 버전의 Interactors와 Entities를 이용해서 Presenters 자체 버전을 빌드하면 그만이다.
- 이 빌드 과정에서 시스템의 나머지 컴포넌트는 전혀 관련이 없다.
- 즉 테스트를 구성할 때 적은 노력이 든다는 것이며, 고려해야할 변수도 상대적으로 적다는 뜻이기도 하다.

<br/>

- 시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.
- 먼저 Entities 컴포넌트를 컴파일하고, 테스트하고, 릴리스한다.
- 그리고 나서 Database와 Interactors에 대해서도 동일한 과정을 거친다.
- Main은 마지막에 처리한다.
- 이 처럼 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.

### 순환이 컴포넌트 의존성 그래프에 미치는 영향

- 새로운 요구사항이 발생해서 Entities에 포함된 클래스 하나가 Authorizer에 포함된 클래스 하나를 사용하도록 변경할 수밖에 없다고 가정해보자.
- 예를 들어 Entities의 User 클래스가 Authorizer의 Permissions 클래스를 사용한다고 해보자.
- 그럼 아래 그림과 같이 순환 의존성이 발생한다.

![](https://uchanlee.dev/static/6005b83720c2dd84929d83b923528691/0a47e/image-14.2.png)

- 이 순환은 즉각적인 문제를 일으킨다.
- 예를 들어, Database 컴포넌트를 만드는 개발자는 컴포넌트를 릴리스 하려면 Entities 컴포넌트와 반드시 호환되어야 한다는 사실을 알고있다.
- 하지만 Entities 컴포넌트에는 순환이 있으므로, Database 컴포넌트 또한 Authorizer와도 호환되어야한다.
- 그런데 Authorizer는 Interacto에 의존한다.
- 즉 Entities, Authorizer, Interactors는 사실상 하나의 거대한 컴포넌트가 되어버린다.
- 즉 이 컴포넌트들 중 어느 것을 개발하더라도 '숙취 증후군'에 떠는 경험을 하게 될 거라는 의미다.

<br/>

- 하지만 이는 겪게 될 문제 중 일부일 뿐이다.
- Entities 컴포넌트를 테스트할 때 무슨일이 벌어질지를 생각해보라.
- 유감스럽게도 Authorizer와 Interactors까지도 반드시 빌드하고 통합해야 한다.
- 뿐만 아니라 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
- 사실 순환이 생기면 올바른 순서라는게 없을 수 있다.

### 순환 끊기

- 컴포넌트 사이의 순환을 끊고 의존성을 다시 비순환 방향 그래프로 원상복구하는 일은 언제라도 가능하다.
- 이를 위한 주요 메커니즘 두 가지를 살펴보자.

<br/>

1. DIP를 적용한다.

![](https://uchanlee.dev/static/7f579cd6cb89c723fb56ee99dd4f20e5/0a47e/image-14.3.png)

- 위 그림처럼 User가 필요로 하는 메서드를 제공하는 인터페이스를 생성한다.
- 그리고 이 인터페이스는 Entities에 위치시키고, Authorizer에서는 이 인터페이스를 상속받는다.
- 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.

<br/>

2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다.

![](https://uchanlee.dev/static/d6ca8fdc9c1a119dc7da195141d491d3/0a47e/image-14.1.png)

- 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 옮긴다.

### 흐트러짐 (Jitters)

- 두 번째 해결책에서 시사하는 바는 요구사항이 변경되면서 컴포넌트 구조도 변경될 수 있다는 사실이다.
- 실제로 어플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다.
- 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다.

## 하향식 (top-down) 설계

- 지금까지의 논의로 우리는 피할 수 없는 결론에 다다르게 된다.
- 즉, 컴포넌트 구조는 하향식으로 설계될 수 없다.
- 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.

<br/>

- 컴포넌트 의존성 다이어그램은 어플리케이션의 기능을 기술하는 일과는 거의 관련이 없다.
- 오히려 컴포넌트 의존성 다이어그램은 어플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다.
- 바로 이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.
- 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문이다.

<br/>

- 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
- 우리는 변덕스러운 이유로 자주 변경되는 컴포넌트로 인해, 그렇지 않았다면 안정적이었을 컴포넌트가 영향받는 일을 원치 않는다.
- 결국 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.

## SDP: 안정된 의존성 원칙 (Stable Dependencies Principle)

| 안정성의 방향으로(더 안정된 쪽에) 의존하라.

- 설계는 결코 정적일 수 없다. 
- CCP를 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다.
- 우리는 변동성을 지니도록 설계한 컴포넌트는 언젠가 변경되리라고 예상한다.
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
- 한 번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.

<br/>

- 이는 소프트웨어가 가진 괴팍함이다.
- 즉, 당신이 모듈을 만들 때는 변경하기 쉽도록 설계했지만, 이 모듈에 누군가가 의존성을 매달아 버리면 당신의 모듈도 변경하기 어려워진다.
- SDP를 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

### 안정성

- 안정성이란 무슨 뜻인가?
- 동전을 옆면으로 세워보라. 이 상태에서 동전은 안정적인가라고 물어보면 아니요라고 말할 것이다.
- 하지만 동전을 건드리지 않는다면 동전은 이 상태로 꽤 오랫동안 서 있을 수 있다.
- 따라서 안정성은 변화가 살생하는 빈도와는 직접적인 관련이 없다.
- 동전의 경우 옆으로 쓰러지는 등 상태가 변하지는 않았지만, 이 상태를 안정적이라고 보기는 어렵다.

<br/>

- 무언가 안정적이라는 말을 웹스터 사전에서는 '쉽게 움직이지 않는'이라고 정의한다.
- 옆면으로 선 동전이 안정적이지 않은 이유는 그다지 힘을 쓰지 않고도 넘어뜨릴 수 있기 때문이다.
- 반면 탁자는 상당히 안정적인데, 탁자를 뒤집으려면 상당한 수고를 감수해야 하기 때문이다.

<br/>

- 이러한 사실과 소프트웨어는 어떤 관련이 있을까?
- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 많은 요인으로
    - 컴포넌트의 크기
    - 컴포넌트의 복잡도
    - 컴포넌트의 간결함
- 등을 예로 들 수 있다.
- 여기에서 이러한 요인들은 모두 무시하고, 좀 더 특이한 요인에 주목하려고 한다.
- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
- 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.

<br/>

![](https://sungjk.github.io/images/2019/10/26/14_5.png)

- 위 그림의 X는 안정된 컴포넌트다.
- 세 컴포넌트가 X에 의존하며, 따라서 X 컴포넌트는 변경하지 말아야 할 이유가 세 가지나 되기 때문이다.
- 이 경우 X는 세 컴포넌트를 책임진다라고 말한다.
- 반대로 X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다.
- 이 경우 X는 독립적이다라고 말한다.

<br/>

![](https://uchanlee.dev/static/edce24d78ce38e44183288b4dad71ec0/0a47e/image-14.6.png)

- 위 그림의 Y는 상당히 불안정한 컴포넌트다.
- 어떤 컴포넌트도 Y에 의존하지 않으므로 Y는 책임성이 없다고 말할 수 있다.
- 또한 Y는 세 개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지다.
- 이 경우 Y는 의존적이라고 말한다.

### 안정성 지표

- 어떻게 하면 컴포넌트 안정성을 측정할 수 있을까?
- 컴포넌트로 들어오고 나오는 의존성의 개수를 세어 보는 방법이 있을 수 있다.
- 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있다.

<br/>

- _Fan-in_: 안으로 들어오는 의존성.
    - 이 지표는 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수를 나타낸다.
- _Fan-out_: 바깥으로 나가는 의존성.
    - 이 지표는 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수를 나타낸다.
- _I_(불안정성): _I_ = _Fan-out_ ÷ (_Fan-in_ + _Fan-out_)
    - 이 지표는 [0, 1] 범위의 값을 갖는다.
    - _I_ = 0이면 최고로 안정된 컴포넌트라는 뜻이다.
    - _I_ = 1이면 최고로 불안정한 컴포넌트라는 뜻이다.
- _Fan-in_ 과 _Fan-out_ 지표는 특정 컴포넌트 내부의 클래스에 의존하는, 컴포넌트 외부에 위치한 클래스이 개수를 세어서 계산할 수 있다.

![](https://user-images.githubusercontent.com/20153890/122218563-89d3e800-cee9-11eb-9d8c-0c64052fd0a9.png)

- Cc 컴포넌트의 안정성을 계산해야 한다고 해보자.
- 보다시피 Cc 내부의 클래스에 의존하며 Cc 외부에 있는 클래스는 세 개다.
- 따라서 _Fan-in_ = 3이다.
- 또한 Cc 내부의 클래스가 의존하는 Cc 외부에 위차한 클래스는 한 개다.
- 따라서 _Fan-out_ = 1이고, _I_ = 1/4 이다.

<br/>

- _I_ 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만, 해당 컴포넌트는 다른 컴포넌트에 의존한다는 뜻이다.
    - 이러한 상태는 컴포넌트가 가질 수 있는 최고로 불안정한 상태다.
    - 이 컴포넌트는 책임성이 없으며 의존적이다.
    - 자신에게 의존하는 컴포넌트가 없으므로, 이 컴포넌트는 변경하지 말아야 할 이유가 없다.
    - 하지만 다른 컴포넌트에 의존하고 있으므로 언젠가 해당 컴포넌트를 변경해야할 이유가 있다는 뜻이다.
- 반대로 _I_ 값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만, 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다는 뜻이다.
    - 이러한 컴포넌트는 다른 컴포넌트를 책임지며 또 독립적이다.
    - 이러한 상태는 컴포넌트가 가질 수 잇는 최고로 안정된 상태다.
    - 자신에게 의존하는 컴포넌트가 있으므로 해당 컴포넌트는 변경하기가 어렵다.
    - 하지만 해당 컴포넌트를 변경하도록 강제하는 의존성은 갖지 않는다.

<br/>

- SDP에서 컴포넌트의 _I_ 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 _I_ 보다 커야 한다고 말한다.
- 즉 의존성 방향으로 갈수록 _I_ 지표 값이 감소해야한다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

- 모든 컴포넌트가 최고록 안정적인 시스템이라면 변경이 불가능하고 이는 바람직한 상황이 아니다.
- 사실 우리가 컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태다.

![](https://uchanlee.dev/static/dc69bd12c60636285300481d41f78c93/0a47e/image-14.8.png)

- 위 다이어그램은 세 컴포넌트고 구성된 시스템이 가질 수 있는 가장 이상적인 구조다.
- 위쪽에는 변경 가능한 컴포넌트가 보이고, 아래의 안정된 컴포넌트에 의존한다.
- 다이어그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 두는데, 이 관례를 따르면 상당히 유용하다.
- 위로 향하는 화살표가 있으면 SDP를 위배하는 (그리고 나중에 보겠지만 ADP도 위반하는) 상태가 되기 때문이다.

![](https://miro.medium.com/max/1400/1*ci7PeVlyEKFeP_HNaGKSWw.png)

- 위 다이어그램에서는 SDP가 어떻게 위배될 수 있는지를 보여준다.
- Flexible은 변경하기 쉽도록 설계한 컴포넌트다. 또한 Flexible은 불안정한 상태이기를 바란다.
- 하지만 Stable 컴포넌트에서 작업하던 개발자가 Flexible에 의존성을 걸게 되었다.
- 이로 인해 SDP를 위배하는데, Stable의 _I_ 지표는 Flexibel의 _I_ 지표보다는 더 작기 때문이다.
- 결국 Flexble은 변경하기가 어렵게 되었다.

<br/>

- 이 문제를 해결하려면 Stable의 Flexible에 대한 의존성을 어떤 식으로든 끊어야한다.

![](https://blog.kakaocdn.net/dn/bvRbbT/btrlQ1Zj89W/hs9dKDpl7zKmpFHk0yRk31/img.png)

- Stable 내부의 클래스 U가 Flexible 내부의 클래스 C를 사용한다고 가정해보자.
- DIP를 도입하면 이 문제를 해결할 수 있다.
- 먼저 US라는 인터페이스를 생성한 후 UServer 컴포넌트에 넣는다.
- 이때 US 인터페이스에는 U가 사용하는 모든 메소드가 반드시 선언되어 있어야한다.

![](https://blog.kakaocdn.net/dn/ddCBVJ/btrlV1XPnuT/Tbge4pPzJ3TZ9JYP2JLU8K/img.png)

- 그리고 위 그림처럼 C가 해당 인터페이스를 구현하도록 만든다.
- 이를 통해 Stable의 Flexible에 대한 의존성을 끊을 수 있고, 두 컴포넌트는 모두 UServe에 의존하도록 강제한다.
- UServe는 매우 안정된 상태이며, Flexible은 자신에게 맞는 불안정성을 그대로 유지할 수 있다.
- 이제 모든 의존성은 _I_ 가 감소하는 방향으로 향한다.

### 추상 컴포넌트

- 오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식이 이상해 보일 수도 있다.
- 자바나 C# 같은 정적 타입 언어를 사용할 때 이 방식은 상당히 흔할 뿐만 아니라, 꼭 필요한 전략으로 알려져있다.
- 이러한 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.

## SAP: 안정된 추상화 원칙 (Stable Abstractions Principle)

| 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

### 고수준 정책을 어디에 위치시켜야 하는가?

- 시스템에는 자주 변경해서는 절대로 안 되는 소프트웨어도 있다.
- 따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트(_I_ = 0)에 위치해야 한다.
- 불안정한 컴포넌트 (_I_ = 1)는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.

<br/>

- 하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다.
- 이로 인해 시스템 전체 아키텍처가 유연성을 잃는다.
- 컴포넌트가 최고 안정된 상태이면서도(_I_ = 0) 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?
- 해답은 OCP에서 찾을 수 있다.
- OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있다.
- 추상 클래스가 이 원칙을 준수한다.

### 안정된 추상화 원칙

- 안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.
- 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다.
- 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.
- 따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야한다.

<br/>

- SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다.
- 실제로 SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하고
- SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다.
- 따라서 의존성은 추상화의 방향으로 향하게 된다.

### 추상화 정도 측정하기

---

# 질의응답

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
규훤:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진호:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```


```text
천규:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
준우:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
이영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
영재:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
태훈:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
가온:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```
