# 진행 자료
# 개요
**SOLID 원칙이란?**

- 로바트 마틴이 기술한 5가지 객체지향프로그래밍의 5가지 법칙의 두문자어를 따온 것
- 좋은 소프트웨어는 깔끔한 코드(clean code)로부터 시작한다. 따라서, 좋은 아키텍처를 만들기 위해선 코드 수준에서부터 정리되어야한다.

**SOLID 원칙의 목적**

- 변경에 유연
- 이해하기 쉽게
- 많은 소프트웨어 시스템에서 사용될 수 있는 컴포넌트 기반

# 7장 - SRP: 단일 책임 원칙

*하나의 모듈(클래스는) 하나의 책임만 가져야 한다.*

```
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
```

이를 조금더 명확히 정의하면 다음과 같다.

```
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
```

### 우발적 중복

![https://miro.medium.com/max/828/0*rYM9F-ekBa7O3DG0.jpg](https://miro.medium.com/max/828/0*rYM9F-ekBa7O3DG0.jpg)

Employee 클래스는 세가지 메서드 calculatePay(), reportHours(), save()를 가진다.

- calculatePay() 메서드는 회계팀에서 기능을 정의하고, CFO 보고를 위해 사용한다.
- reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위헤 사용한다.
- save() 메서드는 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.

여기서 만약 regularHours라는 메서드를 추가한다고 가정해보자. 해당 메서드는 calculatePay 메서드와 reportHours 메서드에 의존한다.

![https://velog.velcdn.com/images%2Fkjy991%2Fpost%2F9dba48fc-0a88-457a-b9bc-dd97f710c6c3%2Fimage.png](https://velog.velcdn.com/images%2Fkjy991%2Fpost%2F9dba48fc-0a88-457a-b9bc-dd97f710c6c3%2Fimage.png)

- CFO팀에서 reportHours 메서드를 수정해버렸다.
- 그러나 COO 팀에서는 수정된 방식을 사용하고 싶어하지 않는다.
- 하지만 개발자는 이을 모르고 그냥 변경한 뒤 적용해버렸다.
- 이로 인해 잘못된 데이터가 출력되고, 수백만 달러의 예산 손실이 일어났다.

### 병함

일반적으로 여러 액터가 의존하는 하나의 클래스(모듈)에 대해 소스코드를 여러 개발자들이 수정하다보면, 필연적으로 한 메서드나 클래스에 대해 충돌이 발생하게 된다.

- 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우
- 늘 그렇듯, 병합에는 위험이 뒤따른다.

### 병합 해결책

![https://miro.medium.com/max/1232/1*TU3rTyvNX76mXIr4VTzoqw.png](https://miro.medium.com/max/1232/1*TU3rTyvNX76mXIr4VTzoqw.png)

- 가장 기본적인 해결책은 메서드를 서로 다른 클래스로 옮기는 것
- 그러나 만약 클래스의 수가 많아진다면? 관리해야하는 수가 많아질수록 비효울적이다.
- 따라서 **파사드(Facade)** 패턴을 사용해 해결하는 방식이 있다.

![https://miro.medium.com/max/1400/0*mDtOoXtAmrM9vKSi.jpg](https://miro.medium.com/max/1400/0*mDtOoXtAmrM9vKSi.jpg)

또는 파사드에 핵심적인 구현내용은 기존 클래스에 그대로 유지하되, 덜 중요한 메서드들을 참조하는 형태로 바꿔서 쓸 수도 있다.



### 결론

- 왜 하나의 액터에 대해서만 책임져야 하는가?

**서로다른 액터가 처음에는 같은 유스케이스를 공유하더라도, 추후에 만약 어느 한 액터에서 유스케이스 변경사항이 생긴다면? 의존하는 또 다른 액터에서도 변경사항이 발생한다. 의도치 않은 변경사항 발생!**

**SRP는 메서드와 클래스 수준의 원칙이다**

# 8장 - OCP: 개방 폐쇄 원칙

*소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.*

```
소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
```

### 사고 실험

재무제표를 웹 페이지로 보여주는 시스템이 있다고 가정해보자

![https://velog.velcdn.com/images/rudaks94/post/5541fa73-43bb-4884-ab72-158ca7e243cb/image.png](https://velog.velcdn.com/images/rudaks94/post/5541fa73-43bb-4884-ab72-158ca7e243cb/image.png)

- 다만, 흑백 프린터로 출력하게끔 만드는 기능도 추가된다고 가정해보자
- 새로운 코드를 작성하는데 있어, 기존 코드를 수정하지 않으려면?
- SRP(단일 책임 원칙)을 이용해 분리한다.

여기서 보고서 생성은 두 개의 책임으로 분리가 된다. 

이 처럼 책임을 분리하였다면, 둘 중 하나가 변경하더라도 다른 하나는 변경이 되지 않도록 조직해야한다.

이러한 처리 과정을 더 확장시켜 클래스 단위와 컴포넌트 단위로 생각해본다.

![https://t1.daumcdn.net/cfile/tistory/9935373A5E43875A02](https://t1.daumcdn.net/cfile/tistory/9935373A5E43875A02)

### 방향성 제어

![https://velog.velcdn.com/images/rudaks94/post/01934358-8ed7-4c71-9066-f0910d45f9cb/image.png](https://velog.velcdn.com/images/rudaks94/post/01934358-8ed7-4c71-9066-f0910d45f9cb/image.png)

- 컴포넌트 간의 관계를 명확히 하는 것도 중요하다. 일반적으로 컴포넌트간의 의존성은 단방향으로만 관계를 가지는 것이 가장 이상적이다.
- 가장 대표적인 MVC 패턴을 생각해보자

### 결론

- 왜 변경에 닫혀있어야 하는가?

**요구사항이 변경되어 새로운 기능을 만드는데 1000줄을 수정하는 것과, 0줄을 수정하는 것의 차이는 결국 OCP를 얼마나 준수하냐에 따라 달려있다.**

**OCP는 계층 수준의 원칙이다.**

# 9장 - LSP: 리스코프 치환 법칙

*프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.*

들어가기 앞서 하위타입의 정의를 먼저 살펴보자

```
여기에서 필요한 것은 다음과 같은 치환 원칙이다. S타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
```

### 상속을 사용하도록 가이드하기

License 클래스가 다음과 같이 존재한다. 이 클래스는 calcFee()라는 메서드를 가지며, 두가지 하위 타입을 가지고 있다.

![https://niqrid2020.pe.kr/wp-content/uploads/2021/02/%EC%BA%A1%EC%B2%981-1024x576.png](https://niqrid2020.pe.kr/wp-content/uploads/2021/02/%EC%BA%A1%EC%B2%981-1024x576.png)

위 구현은 LSP를 잘 준수하고 있다. Billing 어플리케이션은 License가 어떤 하위타입을 사용하는지 알 필요가 없다.

### 정사각형/직사각형 문제 (LSP 위반 사례)

반대로 다음 정사각형/직사각형 클래스는 LSP를 위반한다.

이 예제에서 Square는 Rectangle의 하위 타입으로는 적합하지 않다. 그러나 Square의 높이와 너비는 반드시 함께 변경된다. User는 Rectangle을 보고 있으므로 혼동이 생길 수 있다.

```java
Rectangle r = new Rectangle();
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```

만약 위의 코드를 실행하면 실패하게 된다.

여기서 LSP 위반을 막으려면 if 문을 추가하는 방식 따위로 Square인지 검사하는 매커니즘이 들어가야만 한다.

**그러나 이렇게 하면 타입치환이 불가능해진다.**

### LSP 위배 사례

구체적인 클래스 수준이 아닌 조금더 개략적인 수준인 REST API의 URI 설계로 가정해보자

택시 파견 서비스를 통합하는 어플리케이션을 만들고 있다.

이 때, 택시기사 밥의 택시 파견 URI는 다음과 같다.

```
purplecab.com/driver/Bob
```

그리고 PUT 방식으로 다음과 같이 호출한다.

```
PUT
purplecab.com/driver/Bob
            /pickupAddress/24 Maple ST.
            /pickUpTime/153
            /destination/ORD
```

### 결론

- LSP를 준수하는 것은 아키텍처 관점에서 어떤 이득이 있는가?

**상위 클래스에서는 참조하는 클래스의 세부적인 구현 내용에 관심이 없다.**

**LSP는 메서드와 클래스 그리고 아키텍처 수준의 설계원칙이다.**

# 질의응답

```text
지인:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진영: 모듈이랑 액터가 1대1 매칭되는 관계라는게 SRP라는거같은데 하나의 모듈을 여러액터가 공유하게 되는경우는 아예 없을까요?

대답: 어떤 답변을 원하는 건지 잘 모르겠네요. SRP 위반 사례를 이야기 하는 것인가요...? 음 당장 생각나는 건 횡단관심사에 속하는 모듈은 여러 액터가 보통 공유하는 것 같습니다. (로깅, 보안, 유틸성 함수 등)
```

```text
규훤:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
진호: 7장 - SRP를 지키려면 액터에 따른 변경 가능성이 조금이라도 있는 코드는 중복됨을 감수하면서 모두 따로 작성해야 할까요? 변경 가능성을 예측할 수 있는 방법은 무엇이며, 최대한 중복을 피할수 있는 방법이 있을까요? 예를 들어 regularHours() 메서드를 Template Method 패턴으로 만들면 어떨까요?
대답: 중복을 감수하면서 따로 작성하는 것에 관한 것은 규훤님의 답변을 참조하시면 될 것 같습니다. 변경 가능성을 예측하는 방법...은 처음 설계 할 때부터 액터가 분리되어 있는가?를 유심히 살펴봐야 하지 않을까요? 저도 중복의 대안으로 템플릿메서드를 생각했는데, 좋은 방법이라고 생각합니다. 아니면 비슷한 데코레이터 패턴을 적용하는 방법도 있을 것 같네요.
```

```text
승직:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
천규:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
성준:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```
