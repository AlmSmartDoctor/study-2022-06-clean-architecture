# Ch. 17 경계: 선 긋기
### 소프트웨어 아키텍처
- (경계)선을 긋는 기술
- 목적: 시스템을 만들고 유지하는 ***인적 자원***을 최소화 하는것.
--- 
## 17.1. Sad Story..
책에 나오는 케이스 요약본
### 17.1.1. P회사 케이스
- 데스크탑 GUI 모노리틱 제품.
- 웹버전으로 변환.
    - 3티어 아키텍처,서버 팜 분산, GUI / 미들웨어 / DB
    - 모든 도메인 객체가 각각 다른 머신에 3개씩 인스턴스를 가짐.
    - 레코드에 새로운 필드를 추가하려고 하면..
        - 많은 일을 해야됨(객체 초기화, 직렬, 마샬링, 파싱, 통신..)
- 서버팜 확보 실패
    - 단일 장비에서 해당 프로그램 실행.
        - 추가적인 작업이 불필요하게 많아짐

### 17.1.2. W회사 케이스
- SOA(서비스 지향 아키텍처)로 프로젝트를 구성.
- 객체들로 구성된 도메인 모델 생성.
- 레코드에 새로운 필드를 추가.
    - 할일이 많아짐.


**위 두케이스 모두 아키텍처를 도입했는데, 이른 결정으로 인해 오히려 인적 비용이 더 증가해버린 케이스를 말하고있다.**
- 이러지 말자!

## 17.2. 성공 사례 (FitNesse)
- 상위 원칙: "다운로드 후 바로 실행"
- 초기 결정:
    - 웹서버 직접 구현.
        - 웹 프레임워크에 대한 결정을 연기
    - DB에 대한 결정을 미루자.
    - 업무 규칙과 DB사이에 **"경계선"** 작성

**결과적으로 FitNesse는 굉장히 유연한 프로젝트가 됐다.**

## 17.3. 어떻게 선을 그을까? 그리고 언제 그을까?
- 관련이 있는 것과 없는 것 사이에 선을 긋는다.
    - GUI - 업무 규칙
    - DB - GUI
    - DB - 업무 규칙

### 17.3.1. 업무 규칙과 DB 선긋기
- DatabaseAccess를 보면, 해당 클래스를 알고있는 건 없다!

![](17_2.png)

- 컴포넌트 단위로 한번 보자.
- DB는 BusinessRules 컴포넌트를 알고 있지만, 그반대는 아니다.
- 이러한 구조를 통해서 DB를 **선택사항**으로 남겨두고, 업무 규칙에 대한 개발을 우선적으로 할수 있다.

![](17_3.png)

## 17.4. 입력과 출력은?
- **중요하지 않다는 사실!**

- "시스템의 행위가 입출력에 의한 행위다." 라고 생각하는 경향이 있다.
- 그래서 모델이 존재한다는걸 버린다.
- **중요한 사실은 모델은 사실 인터페이스(GUI)가 필요 없다는 사실이다..**
![](17_4.png)

## 17.5. 플러그인 아키텍처
- GUI, DB가 플러그인의 형태를 띄게됨.
- 플러그인으로써의 컴포넌트의 교체가 좀더 용이해짐
- 물론 교체가 간단한 작업은 아닐거임.
- 결론적으로 플러그인 아키텍처를 통해서 업무 규칙외에 모든게 선택사항으로 취급할 수 있게 해줌.
![](17_5.png)
### 17.5.1. GUI as Plugin
- 웹
- 클라이언트/서버
- SOA
- Console
- etc..

### 17.5.2. DB as Plugin
- SQL
- NoSQL
- FileSystem
- etc..

## 17.6. 플러그인에 대한논의
### 17.6.1. Resharper와 Visual Stuio의 관계
- Resharper: Visual Stuio 확장 플러그인
- Visual Studio와 Resharper는 철저히 비대칭 구조를 가진 관계
  - Resharper -> Visual Studio

### 17.6.2. 플러그인 아키텍처로 원하는 것
- 업무 규칙을 제외한 무언가를 변경하더라도, 우리 업무 규칙은 깨지지 않기를 바람.
- 경계는 변경의 축(axis of change)에 그어진다.
  - 변경의 축을 기반으로 컴포넌트의 개발 주기가 달라진다.
  - 같은 이유로 변경되는 애들끼리 묶여있으므로, SRP, CCP라고 할수 있다.


## Ch.17 결론
- 시스템을 컴포넌트 단위로 분리하고 경계선을 그어라.
- 핵심 업무 규칙 컴포넌트를 찾고, 나머지 컴포넌트는 플러그인으로써 역할을 시킨다.
- 컴포넌트가 특정 방향(핵심 업무 규칙 컴포넌트)으로 향하도록 한다.
- 선 긋기 및 플러그인 구조는 결국, DIP + SAP 의 응용이다.
  - 컴포넌트 결합 설명할때 SDP + SAP => 컴포넌트에 대한 DIP라고 했으니까, 결국 그냥 DIP에 대한 설명이라고 봐도 될것같다.


# Ch.18 경계 해부학
- `시스템 아키텍처 => 컴포넌트 + 경계선`
- 이번챕터는 경계선에 대한 다양한 형태 소개
## 18.1. 경계 횡단하기
- >**"_런타임에 경계를 횡단한다._"**
  - 경계의 한쪽에서 반대편 기능을 호출하는 것.
  - 적절하게 건너는 비결은 **소스코드 의존성 관리**에 있다.
  - 왜냐? -> 하나가 바뀌면 다 바뀌게 될지도 모르니까. => 프로그래머가 **"더"** 굴러야함
  - 경계는 이런 변경이 전파되는걸 막는 방화벽을 구축하고 관리하는 수단.

## 18.2. 두려운 단일체
- 물리적 구분이 없는 형태 (바이트코드상으로)
- **소스 수준 분리 모드** -> Ch.16.결합 분리 모드
- 배포관점에선 모노리스 파일 하나.
  - .exe
  - jar
  - c, c++ 컴파일 실행파일
- 개발 자체를 독립적으로 할수 있게 해주므로 좋다.

### 18.2.1. 일반적인 경계횡단
- Client(저수준)에서 Service(고수준)으로의 횡단.
- 런타임, 컴파일타임 의존성 모두 같은 방향으로 간다.

```kotlin
class Client(
  val service: Service
) {
    fun doSomething() {
        service.f(data) // val data : Data
    }
}
```
- 제어흐름: Client -> Service
- 의존성: Client -> service

### 18.2.2. 소스 수준 분리모드 경계횡단
- 동적 다형성을 사용하여 제어흐름을 바꾸면 (IOC) 의존성(컴파일타임)을 역전시킬 수 있다.
![](18_2.png)
```kotlin
class Client(
  val service: Service
){
    
}

interface Service{
    fun f(data: Data)
}

data class Data(
  val x: Int
)
//---------------------------------------
class ServiceImpl: Service {
    override fun f(data: Data){
        //do work    
    }
}

```
- 제어흐름: Client -> Service -> ServiceImpl
- 경계선에서의 의존성: ServiceImpl -> Service
- 통신 => 단순한 함수 호출 => 빠르다

## 18.3. 배포형 컴포넌트
- 동적 링크 라이브러리를 사용해서 물리적인 경계 나뉨.
- 배포 수준 결합 분리 모드
- 배포과정만 빼면 단일체(모노리스)와 같다.
- 컴포넌트 의존성관리 => 동적 다형성 사용
- 통신 => 함수 호출 => 빠르다
- 동적 링크로 인한 런타임 로딩

## 18.4. 스레드
- 아키텍처 경계, 배포에 대한 건 아님
- 모든 스레드가 하나의 컴포넌트에 포함될 수 있고, 많은 컴포넌트에 걸쳐 분산 될수 있다.
- 왜 갑자기 스레드 설명을 하나싶은데, 
아마도 뒤에서 부턴 독립된 프로그램의 느낌으로 
설명되기 때문에 스레드를 중간에 둬서 모노리스와 배포형 컴포넌트
역시도 컴포넌트들을 독립적으로 배치시킬수 있다는걸 보여주고자 한거같다.

## 18.5. 로컬 프로세스
- 더 강력한 경계의 물리적 형태
- 로컬 프로세스 => 독립된 메모리 공간 사용
- os 기반 통신을 통해 **경계 횡단**이 일어난다.
- 의존성: 저수준 컴포넌트 -> 고수준 컴포넌트
- 통신: os기반 통신이라 이전 애들보단 느림

## 18.6. 서비스
- 더욱더 강력한 경계의 물리적 경계
- "**물리적 위치**"에 구애받지 않음
- 의존성: 저수준 서비스 -> 고수준 서비스
- 통신: 네트워크까지 들어가서 굉~~~장히 느려질수도?

### 정리
- 위 경계 기준은 절대적인 것도 아니며 단 하나만 적용되는 것도 아니다.
- 그래서 내가 봤을때 어떤 기준들이 있을지, 아키텍처에 대한 설명에서 나온것 기반(Ch.15)으로 한번 고려해야될 부분들을 정리해봤다.
  - 개발
  - 배포
  - 운영
  - 유지보수

| 비용   | 단일체(Monolith)                       | 배포수준     | 로컬 프로세스                          | 서비스                                             |
|------|-------------------------------------|----------|----------------------------------|-------------------------------------------------|
| 개발   | (프로젝트 규모, 팀규모)에 따라 개발 효율이 상이할거같다.   | ''       | ''                               | ''                                              | 
| 배포   | 모노리스 프로그램 하나(전체)가 배포됨               | 모듈별 배포   | 프로세스별 배포                         | 서비스 별 배포                                        |
| 운영HW | 단일 머신, 단일 프로세스로 (하드웨어)관리 및 확장성이 어려움 | 모노리스와 같음 | 각각 다른 프로세스이므로 메모리에 대한 최적화 가능 할듯. | 각각의 서비스를 머신별로 나눌수 있으므로 다양한 방식으로 HW를 최적화 시킬수 있음. |
| 유지보수 | 소스코드 수준 분리로 이슈 처리 간단해짐. (규모만 적당하다면) | 모노리스와 같음 | IPC가 추가됨에 따라 추가적으로 관리할게 늘어남.     | 각각의 머신에 대한 관리, 네트워크 통신 관리 등 관리대상은 훨씬 늘어남        | 
- 프로젝트, 팀, 회사의 규모가 커질수록 서비스 쪽으로 가야 관리가 편해질 것 같다.
- 반대로 작은 규모라면, 굳이 서비스 기준으로 나눌 필요까진 없지 않나 싶고.

## 결론.
- 단일체를 제외한 전략들은 여러가지를 선택할 수 있다.

---

# 질의응답

```text
지인: 181p 플러그인 아키텍처를 읽으면서 어디까지를 플러그인으로 봐야하는지 좀 헷갈리네요.
진짜 우리가 플러그인이라고 부르는 것들이 플러그인인건지
아니면 여기서 선택을 미룰 수 있는 것들이 플러그인인건지...

대답: 
"플러그인"이라는 단어자체가 일단, DIP에 대한 개념이 강한 것 같습니다.
최대한 추상적이고 안정적인 컴포넌트를 시스템으로 보고, 나머지를 다 플러그인으로 보는 거죠.
또한, 말하신대로, 선택사항에 대한것 역시 얘기하는것같습니다. 안정적인 컴포넌트(정책)을 제외한 
모든 것들을 세부사항으로 보고 열어두는 거죠.
예를 들어 이책에 예로 나오는 FitNesse를 보면 DB를 선택사항으로 두고 최대한 미뤘다고 했죠.
FitNesse 프로그램(핵심 비즈니스 룰)에서는 DB가 곧 플러그인인 거죠.
지인님이 말씀하신 우리가 플러그인이라고 부르는 것들의 범위가 어디까지인진 모르겠으나,
우리가 흔히 플러그인이라고 부르는 프로그램들 역시(책에서 나온 Resharper, Chrome 확장 프로그램 등등) 
각각 대상이 되는 프로그램(vs, chrome)에게는 세부사항(선택사항)이므로, 모두 같은 개념이라고 봐도
무방할 것같습니다.
```

```text
하진:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
규훤:
많이 어렵지 않은(?) 질문을 가져와 봤습니다.

지난 스터디에 나왔던 서비스 수준 분리 모드와도 상관이 있을 것 같은데,
189p-190p에서 로컬 프로세스 관련된 부분에 로컬 프로세스는 소켓과 같이 
운영체제에서 제공하는 통신 기능을 이용하여 통신을 한다고 나와있습니다.

이런 상황에서는 인터페이스를 강제할 수 없고 "약속"과 "문서"에 의해서 이루어져야 할 것 같은데,
이 부분에 따른 위험성이 프로세스 또는 서비스 수준에서 얻는 이점보다 클지 잘 모르곘습니다.

의존의 방향에 있는 서비스 또는 프로세스가 변경됨에 따라 의존하는 서비스는 아무것도(예: 라이브러리 버전 변경) 안했는데
잘 돌아가던 로직이 변경될 수도 있지 않나 싶은데, 혹시 어떻게 생각하시나요??

대답: 
확실히 모듈/소스코드 수준 분리처럼 함수를 콜하는게 아니다 보니, 빌드시 체크하기 어렵고 
각각의 프로세스, 서비스 인터페이스(통신형식, 데이터 구조)에 민감할 수 밖에 없다는건 맞습니다. 
하지만, 프로젝트의 규모가 커진다면, 단순히 모듈분리, 모노리스구조로 프로그램을 짜기에는 한계점이 분명히 올 것 같습니다. (리소스, 개발 비용 등)
 그런 상황이 온다면, "약속과 문서"를 담당할 수 있는 인력/프로세스를 더 구축하는게 더 개발 비용을 줄일수 있게되는 임계점가 있을것같습니다. 
그리고, 서비스/로컬 프로세스 단위로 경계선의 기준을 올린다면 한가지 확실한 이점을 얻을수 있게됩니다.
언어의 장벽이 없어지는거죠. 플러그인 아키텍처에서 나왔듯이, 
GUI는 자바스크립트로 된 웹페이지일수도, 
혹은, AOS 앱일수도, 
혹은 그냥 c++로 만든 cli일수도있게 됩니다. 
이런 장점은 물론 그만큼 커버할수 있는 능력이 있는 팀/회사 규모가 있어야 할 것 같습니다.

결론적으로 말하자면 굉장히 답을 모호하게 하는 걸수 있지만 ,각 구조에 대한 확실한 장단점이 있으니, 
각자의 상황에 맞는 구조를 채택해가는게 현명하지 않나 싶습니다.
```

```text
진호:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
천규: 의존성 역전에 관해 질문이 있습니다.
188p에서 "...런타임 의존성은 컴파일타임 의존성과는 반대가 된다." 라는 표현이 나오는데,
이 말이 잘 이해가 되지 않습니다. 찾아보니 컴파일타임은 클래스와 관련있고
런타임은 객체와 관련있다고 하는데, 뭔가 명확하게 와닿지를 않네요.
혹시 그림 18.2를 이용하여 설명해 주실 수 있을까요?

대답: 저도 이 부분이 헷갈려서 이것 저것 찾아봤는데 말이죠.. 찾아봤을때
런타임 의존성: 실행시에 결정되는 의존성,
컴파일타임 의존성: 컴파일시에 결정되는 의존성
이라는 굉장히 당연한 말은 하는 사람들이 많더군요. 
제가 판단했을때는, 컴파일타임 의존성은 우리가 작성한 코드가 컴파일될 때, 
즉, 우리의 코드 그 자체를 말하는거 같습니다.(혹은 지금 책에서 흔히 말하는 그냥 "의존성")
반대로 런타임의 경우에는 실행되는 바이트코드에 의해서 결정되는 의존성인것같습니다. 
이경우엔 변수에 사용되던 인터페이스들에 실제 구현체들이 할당, 혹은 DI됐기 때문에 
이때의 의존성은 실제 구현체쪽으로 가게 되어있는것같습니다.(의존받는 클래스 -> 인터페이스 -> 구현체), 
컴파일 타임 의존성이 "의존성"이었다면, 런타임 의존성은 책에서 말하고 있는 
"제어흐름"과 같다고 보시면 될것같습니다.
이걸 토대로 18.2 이미지를 보면, 모든 화살표의 방향은 컴파일 의존성이라고 보면될것같고, 
런타임 의존성의 경우, 
- Client -> Service
- Service -> ServiceImpl : 이곳(경계선)에서 의존성이 반대로 위치함
- Client -> Data
- ServiceImpl -> Data
이렇게 의존성이 존재하고 경계선 쪽에서 서로 반대가 된다고 이해하시면 될것같습니다.
```

```text
준우: 저자가 이야기하는 고도로 추상화된 비즈니스 로직의 경계선 긋기는 너무 이상적인 경우에나 먹히는 이야기가 아닌가라는 생각이 듭니다. 
실제로 과연 세부사항이 업무규칙에 영향을 주는 경우는 정말로 없다고 말할 수 있을까요? 반례가 하나 정도는 있을 것 같은데 예시를 들어주시면 감사하겠습니다.

대답: 
애매하군요..
솔직히 저는 그런게 없을거 같다고 생각합니다.(비즈니스 로직과 그 구현을 위한 언어를따로 본다면, 언어도 세부사항일테니까 그정도?)

- 이 주제는 얘길좀 해봐야될것같아요.
결과)
- ans: IO 단에서 사용할수 없는 기능이 비즈니스 로직에 있어서, 해당 유스케이스를 사용할수 없어진다
 - 결국 결과를 보여주는것도 GUI쪽이니까 비즈니스로직과는 상관이없다.!
 
 결론) 안된다.
```

```text
이영:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
영재:

대답: (PR에서 suggest로 커밋하기 편하게 질문 작성 후 이 구문은 지워주세요 ㅎㅎ)
```

```text
가온: 아키텍처 경계 중 로컬 프로세스는 각각이 독립된 주소 공간에서 메모리 공유를 철저히 방지하며 실행된다고 했습니다.
그렇다면 앞 페이지에 나온 컴포넌트 단위로 쪼갤 때는, 동일한 프로세서와 메모리 주소 공간을 기반으로 하는 이유가 있나요?
컴포넌트라는 것이 플러그인을 매개로 해서 어떻게보면 독립적으로 움직이게 하는 것이라고 이해했는데 그렇다면 메모리 공간도 애초에 독립적으로 써야 할 것이라고 생각했습니다. 아니면 이것 또한 아키텍처 레벨에서는 고려하지 않아야 하는(고려하기에 너무 세부사항에 속하는) 것인가요?



대답:
제가 이해한 바로는 배포형 컴포넌트 기준의 분리는 "배포만" 할 수 있을 뿐이라는 걸 의미하는것 같고 로컬 프로세스는 "운영도"따로 할수 있다는 것같습니다. 즉, 동일한 프로세서와 메모리 주소 공간이라는 조건을 걸어둠으로써 다음에 나오는 로컬프로세스와 차이를 두기 위한거죠.
배포형 같은 경우에는 한 모듈이 터진다면, 프로세스 자체가  터지게 됩니다. (메모리를 공유하므로)
하지만 로컬 프로세스같은경우에는 특정 프로세스가 터진다고해서 그게 아키텍처 전체의 크래시를 의미하진 않습니다.(의존성 전이만 없으면) 
가온님 말대로 이부분 역시 세부사항이 맞아서, 최대한 열어두고, 이후 프로젝트의 상황이 변화할때마다 변경될수 있는 구조가 되어야할것같아요. 
```
